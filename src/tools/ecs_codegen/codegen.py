#!/usr/bin/env python3

import sys
import os
import clang.cindex
import clang_utils as clu
from dataclasses import dataclass, field
from typing import List, Dict

@dataclass
class FieldInfo:
    name: str
    type: str

@dataclass
class ComponentDescription:
    name: str
    attributes: List[str] = field(default_factory=list)
    fields: List[FieldInfo] = field(default_factory=list)

def handle_args(in_args=None):
    from optparse import OptionParser, OptionGroup
    parser = OptionParser("usage: %prog [options] {filename(s)}")
    parser.disable_interspersed_args()  # https://docs.python.org/3/library/optparse.html#optparse.OptionParser.disable_interspersed_args
    #
    clo = OptionGroup(parser, "clang options")
    clo.add_option('-a', '--clang-args', default="",
                   help="arguments to be passed to clang, eg --clang-args='-std=c++11'")
    #clo.add_option("--clang-version", default=clang_version if clang_version else clu.version_default,
    #                help="specify a clang version number for finding the clang library. [default: %default]")
    #clo.add_option("--clang-version-fallback", default=",".join(clu.version_fallback),
    #                help="specify a sequence of comma-separated version numbers to fall back on if libclang is not found in the original clang-version. [default: %default]")
    clo.add_option("--clang-libdir", default=None,
                    help="directly specify the directory where libclang is located. This will bypass the clang-version lookup. [default: %default]")
    parser.add_option_group(clo)
    #
    if in_args:
        opts, args = parser.parse_args(in_args)
    else:
        opts, args = parser.parse_args()
        if len(args) == 0:
            parser.error('invalid number of arguments')
    #
    return opts, args

def find_ecs_components(node, target_file, component_descriptions):

    print(f"node.kind: {node.kind} node.spelling: {node.spelling}")
    if node.kind == clang.cindex.CursorKind.STRUCT_DECL and node.location.file != None and node.location.file.name == target_file:
        component_description = ComponentDescription(name=node.type.spelling)

        if node.referenced is not None:
            for c in node.referenced.get_children():
                if c.kind == clang.cindex.CursorKind.ANNOTATE_ATTR:
                    component_description.attributes.append(c.spelling)

        for child in node.get_children():
            if child.kind == clang.cindex.CursorKind.FIELD_DECL:
                component_description.fields.append(FieldInfo(child.spelling, child.type.spelling))
                #print(f"node.location.file.name: {node.location.file.name} node.spelling: {node.spelling} child.spelling: {child.spelling} child.type.spelling: {child.type.spelling} ")
                #fields.append((child.spelling, child.type.spelling))
            else:
                #print(f"!!!!!node.location.file.name: {node.location.file.name} node.spelling: {node.spelling} child.spelling: {child.spelling} child.type.spelling: {child.type.spelling} ")
                find_ecs_components(child, target_file, component_descriptions)
        component_descriptions.append(component_description)
    else:
        for child in node.get_children():
            find_ecs_components(child, target_file, component_descriptions)

def main():
    opts, args = handle_args(sys.argv)

    if len(args) < 3:
        print("Usage: codegen.py <input.ecs.cpp> <output.gen.cpp>"  )
        sys.exit(1)

    clu.load_clang(opts.clang_libdir)

    input_file = args[1]
    output_file = args[2]

    print(f"[ECS-CODEGEN] Parsing {os.path.basename(input_file)} -> {os.path.basename(output_file)}", flush=True)

    print("Input file absolute path:", os.path.abspath(input_file), flush=True)
    clang_version = clang.cindex.conf.get_cindex_library()
    print("libclang loaded:", clang_version, flush=True)

    clang_args = opts.clang_args.split() if opts.clang_args else ['-std=c++17', '-fsyntax-only', '-ferror-limit=0', '-Wno-error']
    try:
        tu = clu.parse_file(input_file, args=clang_args)
    except Exception as e:
        print(f"Error parsing: {e}", flush=True)
        sys.exit(1)

    components = []
    find_ecs_components(tu.cursor, input_file, components)

    output_dir = os.path.dirname(output_file)
    if output_dir:
        os.makedirs(output_dir, exist_ok=True)

    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("// Auto-generated by RTTR Codegen\n")
        f.write('#include "{}"\n\n'.format(os.path.basename(input_file)))
        f.write("void RegisterDummy() {\n")
        for component in components:
            print(f"Component: {component.name}", flush=True)
            for attr in component.attributes:
                print(f"  Attribute: {attr}", flush=True)
            for field in component.fields:
                print(f"  Field: {field.name} ({field.type})", flush=True)
            f.write('    rttr::registration::class_<{}>("{}")'.format(component.name, component.name))
            for field in component.fields:
                f.write('\n        .property("{}", &{}.{})'.format(field.name, component.name, field.name))
            f.write(';\n')
        f.write("}\n")


if __name__ == "__main__":
    main()
